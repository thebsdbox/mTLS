package main

//go:generate go run github.com/cilium/ebpf/cmd/bpf2go -type Config mirrors ./ebpf/mirrors.c

import (
	"bufio"
	"context"
	"flag"
	"fmt"
	"io"
	"log"
	"net"
	"os"
	"os/signal"
	"strconv"
	"strings"
	"syscall"

	"github.com/apparentlymart/go-cidr/cidr"
	"github.com/cilium/ebpf"
	"github.com/cilium/ebpf/link"
	"github.com/cilium/ebpf/rlimit"
)

const (
	SO_ORIGINAL_DST = 80 // Socket option to get the original destination address
)

type Config struct {
	ProxyPort      int
	ClusterPort    int
	Address        string
	ClusterAddress string // For Debug purposes
	CgroupOverride string // For Debug purposes

	PodCIDR string
}

// SockAddrIn is a struct to hold the sockaddr_in structure for IPv4 "retrieved" by the SO_ORIGINAL_DST.
type SockAddrIn struct {
	SinFamily uint16
	SinPort   [2]byte
	SinAddr   [4]byte
	// Pad to match the size of sockaddr_in
	Pad [8]byte
}

func main() {
	var c Config
	flag.StringVar(&c.Address, "address", "127.0.0.1", "Address to bind to, can also be a hostname")
	flag.StringVar(&c.ClusterAddress, "overrideAddress", "", "Address to force all traffic to")
	flag.StringVar(&c.CgroupOverride, "cgroupPath", "/sys/fs/cgroup", "Path for cgroup")
	flag.IntVar(&c.ProxyPort, "proxyPort", 18000, "Port for internal proxy")
	flag.IntVar(&c.ClusterPort, "clusterPort", 18001, "External port for cluster connectivity (TLS)")
	flag.StringVar(&c.PodCIDR, "podCIDR", "10.244.0.0/16", "The CIDR range used for POD IP addresses")
	flag.Parse()

	ctx, stop := signal.NotifyContext(context.Background(), os.Interrupt, syscall.SIGTERM)
	defer stop()

	// Lookup for environment variable
	envAddress, exists := os.LookupEnv("KUBE_NODE_NAME")
	if exists {
		c.ClusterAddress = envAddress
	}
	_, gateway := os.LookupEnv("KUBE_GATEWAY")

	i, err := net.ResolveIPAddr("", c.Address)
	if err != nil {
		panic(err)
	}
	c.Address = i.String()
	if !gateway {
		// Remove resource limits for kernels <5.11.
		if err := rlimit.RemoveMemlock(); err != nil {
			log.Print("Removing memlock:", err)
		}

		// Load the compiled eBPF ELF and load it into the kernel
		// NOTE: we could also pin the eBPF program
		var objs mirrorsObjects
		if err := loadMirrorsObjects(&objs, nil); err != nil {
			log.Print("Error loading eBPF objects:", err)
		}
		defer objs.Close()

		// Attach eBPF programs to the root cgroup
		connect4Link, err := link.AttachCgroup(link.CgroupOptions{
			Path:    c.CgroupOverride,
			Attach:  ebpf.AttachCGroupInet4Connect,
			Program: objs.CgConnect4,
		})
		if err != nil {
			log.Print("Attaching CgConnect4 program to Cgroup:", err)
		}
		defer connect4Link.Close()

		sockopsLink, err := link.AttachCgroup(link.CgroupOptions{
			Path:    c.CgroupOverride,
			Attach:  ebpf.AttachCGroupSockOps,
			Program: objs.CgSockOps,
		})
		if err != nil {
			log.Print("Attaching CgSockOps program to Cgroup:", err)
		}
		defer sockopsLink.Close()

		sockoptLink, err := link.AttachCgroup(link.CgroupOptions{
			Path:    c.CgroupOverride,
			Attach:  ebpf.AttachCGroupGetsockopt,
			Program: objs.CgSockOpt,
		})
		if err != nil {
			log.Print("Attaching CgSockOpt program to Cgroup:", err)
		}
		defer sockoptLink.Close()

		_, cidrNet, err := net.ParseCIDR(c.PodCIDR)
		if err != nil {
			panic(err)
		}
		start, end := cidr.AddressRange(cidrNet)
		cidr := strings.Split(c.PodCIDR, "/")
		if len(cidr) < 1 {
			panic(fmt.Errorf("error parsing cidr %s", c.PodCIDR))
		}

		// Update the proxyMaps map with the proxy server configuration, because we need to know the proxy server PID in order
		// to filter out eBPF events generated by the proxy server itself so it would not proxy its own packets in a loop.
		var key uint32 = 0
		i, err := strconv.Atoi(cidr[1])
		if err != nil {
			// ... handle error
			panic(err)
		}
		config := mirrorsConfig{
			ProxyPort: uint16(c.ProxyPort),
			ProxyPid:  uint64(os.Getpid()),
			ProxyAddr: uint32(ToInt(c.Address)),
			StartAddr: uint32(ToInt(start.String())),
			EndAddr:   uint32(ToInt(end.String())),
			Network:   uint32(ToInt(cidr[0])),
			Mask:      uint16(i),
		}

		err = objs.mirrorsMaps.MapConfig.Update(&key, &config, ebpf.UpdateAny)
		if err != nil {
			log.Fatalf("Failed to update proxyMaps map: %v", err)
		}

		// Start the proxy server on the localhost
		// We only demonstrate IPv4 in this example, but the same approach can be used for IPv6

		internalListener := c.startInternalListener()
		defer internalListener.Close()
		go c.start(internalListener, true)

	}

	externalListener := c.startExternalListener()
	defer externalListener.Close()

	go c.start(externalListener, false)
	_, exists = os.LookupEnv("DEBUG")
	if exists {
		go cat()
	}
	<-ctx.Done() // We wait here

}

func readLines(r io.Reader) {
	rd := bufio.NewReader(r)
	for {
		line, err := rd.ReadString('\n')
		if err == io.EOF {
			break
		}
		if err != nil {
			panic(fmt.Sprintf("Error reading lines %v", err))
		}

		fmt.Printf("%s", line)

	}
}

func cat() {
	file, err := os.Open("/sys/kernel/debug/tracing/trace_pipe")
	if err != nil {
		fmt.Printf("Error trace pipe %v\n", err)
		return
	}
	defer file.Close()
	readLines(file)
}
