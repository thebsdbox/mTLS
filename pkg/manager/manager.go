package manager

//go:generate go run github.com/cilium/ebpf/cmd/bpf2go -type Config mirrors ../../ebpf/mirrors.c

import (
	"bufio"
	"context"
	"flag"
	"fmt"
	"io"
	"net"
	"os"
	"os/signal"
	"smesh/pkg/connection"
	"strconv"
	"strings"
	"syscall"

	"github.com/cilium/ebpf"
	"github.com/cilium/ebpf/link"
	"github.com/cilium/ebpf/rlimit"
	"github.com/docker/docker/pkg/parsers/kernel"
	"github.com/gookit/slog"
)

// This sets upp all of the internal logic, and loads the eBPF

var tracker struct {
	objs         mirrorsObjects // out eBPF objects
	cg           link.Link
	connect4Link link.Link
	sockopsLink  link.Link
	sockoptLink  link.Link
}

func LoadEPF(c *connection.Config) error {
	v, err := kernel.GetKernelVersion()
	if err != nil {
		slog.Errorf("unable to parse kernel version %v", err)
	}

	slog.Infof("detected Kernel %d.%d.x", v.Kernel, v.Major)

	// Remove resource limits for kernels <5.11.
	if v.Kernel >= 5 && v.Major >= 11 {
		if err := rlimit.RemoveMemlock(); err != nil {
			return fmt.Errorf("removing memlock: %v", err)
		}
	}

	// Load the compiled eBPF ELF and load it into the kernel
	// NOTE: we could also pin the eBPF program
	//var objs mirrorsObjects
	if err := loadMirrorsObjects(&tracker.objs, nil); err != nil {
		return fmt.Errorf("loading eBPF objects: %v", err)
	}
	//defer objs.Close()
	// Attach eBPF programs to the root cgroup
	tracker.connect4Link, err = link.AttachCgroup(link.CgroupOptions{
		Path:    c.CgroupOverride,
		Attach:  ebpf.AttachCGroupInet4Connect,
		Program: tracker.objs.CgConnect4,
	})
	if err != nil {
		return fmt.Errorf("attaching CgConnect4 program to Cgroup: %v", err)
	}
	// defer connect4Link.Close()

	tracker.sockopsLink, err = link.AttachCgroup(link.CgroupOptions{
		Path:    c.CgroupOverride,
		Attach:  ebpf.AttachCGroupSockOps,
		Program: tracker.objs.CgSockOps,
	})
	if err != nil {
		return fmt.Errorf("attaching CgSockOps program to Cgroup: %v", err)
	}
	// defer sockopsLink.Close()

	tracker.sockoptLink, err = link.AttachCgroup(link.CgroupOptions{
		Path:    c.CgroupOverride,
		Attach:  ebpf.AttachCGroupGetsockopt,
		Program: tracker.objs.CgSockOpt,
	})
	if err != nil {
		return fmt.Errorf("attaching CgSockOpt program to Cgroup: %v", err)
	}
	// defer sockoptLink.Close()
	// Update the proxyMaps map with the proxy server configuration, because we need to know the proxy server PID in order
	// to filter out eBPF events generated by the proxy server itself so it would not proxy its own packets in a loop.

	cidr := strings.Split(c.PodCIDR, "/")
	if len(cidr) < 1 {
		return fmt.Errorf("error parsing cidr %s", c.PodCIDR)
	}

	var key uint32 = 0
	i, err := strconv.Atoi(cidr[1])
	if err != nil {
		// ... handle error
		return err
	}
	config := mirrorsConfig{
		ProxyPort: uint16(c.ProxyPort),
		ProxyPid:  uint64(os.Getpid()),
		ProxyAddr: uint32(connection.ToInt(c.Address)),
		Network:   uint32(connection.ToInt(cidr[0])),
		Mask:      uint16(i),
	}

	err = tracker.objs.mirrorsMaps.MapConfig.Update(&key, &config, ebpf.UpdateAny)
	if err != nil {
		slog.Fatalf("Failed to update proxyMaps map: %v", err)
	}

	return nil
}

func cleanup() {
	tracker.objs.Close()
	tracker.connect4Link.Close()
	tracker.sockopsLink.Close()
	tracker.sockoptLink.Close()
}

func Setup() (*connection.Config, error) {
	var c connection.Config
	flag.StringVar(&c.Address, "address", "127.0.0.1", "Address to bind to, can also be a hostname")
	flag.StringVar(&c.ClusterAddress, "overrideAddress", "", "Address to force all traffic to")
	flag.StringVar(&c.CgroupOverride, "cgroupPath", "/sys/fs/cgroup", "Path for cgroup")
	flag.IntVar(&c.ProxyPort, "proxyPort", 18000, "Port for internal proxy")
	flag.IntVar(&c.ClusterPort, "clusterPort", 18001, "External port for cluster connectivity")
	flag.IntVar(&c.ClusterTLSPort, "clusterTLSPort", 18443, "External port for cluster connectivity (TLS)")
	flag.StringVar(&c.PodCIDR, "podCIDR", "10.244.0.0/16", "The CIDR range used for POD IP addresses")
	flag.Parse()

	// Lookup for environment variable
	envAddress, exists := os.LookupEnv("KUBE_NODE_NAME")
	if exists {
		c.ClusterAddress = envAddress
	}
	//_, gateway := os.LookupEnv("KUBE_GATEWAY")

	i, err := net.ResolveIPAddr("", c.Address)
	if err != nil {
		return nil, err
	}
	c.Address = i.String()

	// Overwrite the podcidr
	podCIDR, exists := os.LookupEnv("POD_CIDR")
	if exists {
		c.PodCIDR = podCIDR
	}

	return &c, nil
}

// This is a blocking function
func Start(c *connection.Config) error {
	ctx, stop := signal.NotifyContext(context.Background(), os.Interrupt, syscall.SIGTERM)
	defer stop()
	// Start the proxy server on the localhost
	// We only demonstrate IPv4 in this example, but the same approach can be used for IPv6
	c.Socks = tracker.objs.MapSocks
	internalListener := c.StartInternalListener()
	defer internalListener.Close()
	go c.StartListeners(internalListener, true)

	var err error
	externalListener := c.StartExternalListener()
	defer externalListener.Close()

	// Attempt to get certificates from API
	// c.Certificates, err = getKubeCerts(os.Getenv("KUBECONFIG"))
	// if err != nil {
	// 	slog.Error(err)
	// Attempt to get from environment secrets

	c.Certificates, err = connection.GetEnvCerts()
	if err != nil {
		slog.Error(err)
		c.Certificates, err = connection.GetFSCerts()
		if err != nil {
			slog.Error(err)
		}
	}

	// If we have secrets enable a TLS listener
	if c.Certificates != nil {
		externalTLSListener := c.StartExternalTLSListener()
		defer externalTLSListener.Close()
		go c.StartTLSListener(externalTLSListener)
	}

	go c.StartListeners(externalListener, false)
	_, exists := os.LookupEnv("DEBUG")
	if exists {
		go cat()
	}
	<-ctx.Done() // We wait here

	return nil
}

func readLines(r io.Reader) {
	rd := bufio.NewReader(r)
	for {
		line, err := rd.ReadString('\n')
		if err == io.EOF {
			break
		}
		if err != nil {
			panic(fmt.Sprintf("Error reading lines %v", err))
		}

		fmt.Printf("%s", line)

	}
}

func cat() {
	file, err := os.Open("/sys/kernel/debug/tracing/trace_pipe")
	if err != nil {
		fmt.Printf("Error trace pipe %v\n", err)
		return
	}
	defer file.Close()
	readLines(file)
}
